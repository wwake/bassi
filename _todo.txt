* Make interpreter work one line at a time
* Delete Parse.program if we work one line at a time
* GOTO
* IF
* Expressions: variables
* Expressions: functions
* Expressions: subscripts
* Simple assignment ("LET")
* Make running write to an output stream
* PRINT with strings
* PRINT with multiple expressions
   25 PRINT 42 21    -- is legal
* PRINT with ","
* PRINT with ";"
* Track line # of error messages
* Error sync by skipping forward to next line # (or end)

Parameterized tests package?

BI-22-08: May 19, 2022
* Precedence low to high: relational, NOT, AND, OR
* Add eol token to prevent - Program with plain PRINT will use line number of the next line eg
   20 PRINT
   30 PRINT 42
* Make parser check for end of line
    25 A = 42 21 "HI"  -- error
    40 PRINT PRINT   -- error

BI-22-07: May 18, 2022
* Expressions with relational operators
* Exponentiation has higher precedence than unary minus
* Add all reserved words to lexer


BI-22-06: May 17, 2022
* REPL - LIST (sort line numbers numerically)
* REPL - RUN
* Unary "-"

BI-22-05: May 13, 2022
* Expressions with floating point - handle errors! (missing digits in exponent)
* Error message for bad factor
* Straighten out the types
* REPL - enter code

BI-22-04: May 12, 2022
* Expressions with single-character operators

BI-22-03: May 11, 2022
* Error handling w/try-catch
* PRINT with numbers
* Expressions with parentheses
* PRINT with expressions

BI-22-02: May 10, 2022
* Should Lexer be a Sequence? Yes, and IteratorProtocol too.
* Should Lexer work with [Character]? No, but we did clean up indexing.
* Run a REM-only program
* PRINT (no arguments)


BI-22-01: May 9, 2022
* Line Numbers
* Squeezing characters before lexing
* End of program ("Token.atEnd")
* REM


GRAMMAR:
program -> line*

line -> line-number statement "\n"

line-number -> INTEGER(INT)

statement -> "REM" .*
statement -> "PRINT" expression?

expression -> orExpr

orExpr -> andExpr (OR andExpr)*

andExpr -> negation (AND negation)*

negation -> NOT negation
         -> relational

relational -> subexpr (relop subexpr)?

subexpr -> term (("+"|"-") term)*

term -> power (("*"|"/") power)*

power -> "-" power
power -> factor ("^" factor)*

factor -> INTEGER(INT)
factor -> NUMBER(FLOAT)
factor -> "(" expression ")"

Number => [0-9]+("."[0-9]+)?([Ee][+-]?[0-9]+)?

Legal:
123
1234.5
1233E2
123.34e-14

Not legal:
123.
123.E3
123E
123.4E



Semantics:
* Arithmetic operators (+, -, *, /, ^) convert their arguments to "Float"
* Logical operators convert their arguments to "Short" - error if out of range
??? Does it truncate or round?
* Relationals convert numeric values to Float
* Strings can only work with relational operators
* Relationals can work with two numbers or two strings, but not mixed


10 PRINT "foo", 42.375, 10 + 2


REPL
LIST
RUN
enter code
SAVE
LOAD
NEW
